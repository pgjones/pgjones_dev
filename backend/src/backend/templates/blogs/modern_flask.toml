date = "2023-02-06"
id = "modern-flask-2023"
summary = """
With Flask approaching 13 years old I thought it would be helpful to
compile 13 tips and techniques to get the most out of Modern Flask.
"""
title = "13 tips and techniques for modern Flask apps"

body = """

Flask is approaching its 13th birthday in active development, with new
features that make it easier for you to build your web application
continually being added. Thirteen years ago the industry and Flask
focused on server rendered pages, now there is a strong focus on JSON
APIs. Flask has kept up with this change by adding features that make
API development easier.

In this article I've picked out 13 tips, for the 13 years of
development, that make modern Flask ideal. To begin with, here is a
simple teaser of what is possible:

```python
from flask import Flask, ResponseReturnValue

app = Flask(__name__)

@app.get("/")
def index() -> ResponseReturnValue:
    return {"hello": "world"}
```

## 1. Shorthand method decorators

Flask pioneered the concise decorator approach for defining the
path-handler relationship in a form that allows for multiple
HTTP-methods. This is particularly useful for server rendered forms,
as shown:

```python
from flask import redirect, render_template, request, url_for

@app.route("/page", methods={"GET", "POST"})
def page():
    if request.method:
        ...  # Handle form post
        return redirect(url_form("home"))
    return render_template("form.html")
```

When writing APIs this syntax can get cumbersome and so the modern
approach in Flask is to use a shorthand when only one HTTP-method is
needed, as shown:

```python
@app.post("/resource")
def create_resource():
    data = request.get_json()
    ...
```

All the common HTTP-methods `{GET, POST, PUT, DELETE, PATCH}` are
available in shorthand whilst the other methods `{HEAD, CONNECT,
OPTIONS, TRACE}` are automatically handled by Flask.

## 2. JSON return values

Flask provides the `jsonify` function to create a JSON response,
rather than a HTML response:

```python
from flask import jsonify

@app.get("/")
def resource():
    return jsonify({"attribute": "data"})
```

As with the `route` decorator, this syntax can be cumbersome and so
the modern approach is to return the dictionary directly:

```python
@app.get("/")
def resource():
    return {"attribute": "data"}
```

I find in practice it is preferable to always return an envelope,
however list responses are also understood as JSON:

```python
@app.get("/")
def resource():
    return [1, 2, 3]
```

## 3. Configuration via the environment

A [Twelve-Factor](https://12factor.net/) app will store its config in
the environment rather than in a file or elsewhere. This is now
supported in Flask via the config `from_prefixed_env` method:

```python
app.config.from_prefixed_env()
```

Which loads all the environment variables starting with `FLASK_` into
the config so that `FLASK_KEY=1` means `app.config["KEY"] == 1`.

As environment variables are not universally liked, Flask still allows
for loading from a file in any format you like:

```python
import json
import tomllib

app.config.from_file("config.toml", tomllib.loads)
app.config.from_file("config.json", json.loads)
```

## 4. Autogenerated OpenAPI documentation

When writing RESTful APIs, OpenAPI has become the go to standard for
documenting the API for both human and computer usage. On this basis
many libraries that offer serialisation and validation have added
autogeneration of OpenAPI schemas. As always Flask takes a agnostic
stance with the Flask ecosystem suppling many great options. For
example with Marshmallow, consider [APIFlask](https://apiflask.com/):

```python
from apiflask import APIFlask, Schema
from apiflask.fields import Integer, String

app = APIFlask(__name__)

class PetOut(Schema):
    id = Integer()
    name = String()
    category = String()

@app.get("/pets/<int:pet_id>")
@app.output(PetOut)
def get_pet(pet_id):
    ...
```

Which has autogenerated docs at `/docs` by default.

Alternatively if you prefer [Pydantic's](https://docs.pydantic.dev)
syntax, consider
[Spectree](https://github.com/0b01001001/spectree):

```python
from pydantic import BaseModel
from spectree import Response, SpecTree

spec = SpecTree("flask")

class PetOut(BaseModel):
    id: int
    name: str
    category: str

@app.get("/pets/<int:pet_id>")
@spec.validate(resp=Response(HTTP_200=PetOut))
def get_pet(pet_id):
    ...
```

There are many more libraries in the ecosystem if you prefer a
different syntax.

## 5. Type hinting

Using type hints and type checkers have really improved the quality of
my code. Fortunately, Flask is fully type hinted which helps ensure
any code I write using Flask is also checked. For example the
`ResponseReturnValue` type can be used to check that you return a
valid value:

```python
from flask import ResponseReturnValue

@app.get("/")
def index() -> ResponseReturnValue:
    headers = {}
    status = 200
    return "Hello", headers, status  # Type checkers will error here
```

As the correct return value should be `return "Hello", status,
headers` type checkers will error saving an annoying runtime failure.

Please note that `ResponseReturnValue` does not have to be used, a
specific return value will also be checked.

## 6. Using async libraries

With the introduction of async/await in Python 3.5 many new libraries
have been written utilising the syntax. To use these libraries the
calling code must be a async function. This is now possible in flask:

```python
import httpx

@app.get("/")
async def index():
    async with httpx.AsyncClient() as client:
        result = await client.get("https://www.example.com")
```

See also #10 Using Quart, for more on async.

## 7. Nested blueprints

Flask allows apps to be split into blueprints, thereby allowing
related routes to be grouped together. Modern Flask allows nested
blueprints, thereby allowing related routes to be grouped together
across multiple blueprints.

As an example consider having an monitor blueprint that you wish to
use on both the shop and admin parts of your app:

```python
shop = Blueprint("shop", __name__)
admin = Blueprint("admin", __name__)

monitor = Blueprint("monitor", __name__)

@monitor.get("/")
def status():
    retrun {"running": True}

admin.register_blueprint(monitor, url_prefix="/monitor")
shop.register_blueprint(monitor, url_prefix="/monitor")

app.register_blueprint(admin, url_prefix="/admin")
app.register_blueprint(shop, url_prefix="/shop")
```

The paths `/admin/monitor` and `/shop/monitor` now both call the
`status` route-handler. Alternatively to using url prefixes Blueprints
can also be given subdomains that nest.

## 8. Customising JSON serialisation

By default Flask serialises JSON using the standard library `json`
module. This can be customised, for example to support additional
features, or to utilise a more performant serialiser. This
customisation is achieved by implementing a JSONProvider. For example
using [orjson](https://pypi.org/project/orjson) (a faster serialiser)
can be achieved via:

```python
import orjson
from flask.json.provider import JSONProvider

class OrJSONProvider(JSONProvider):
    def dumps(self, obj, *, option=None, **kwargs):
        if option is None:
            option = orjson.OPT_APPEND_NEWLINE | orjson.OPT_NAIVE_UTC

        return orjson.dumps(obj, option=option).decode()

    def loads(self, s, **kwargs):
        return orjson.loads(s)

app.json = OrJSONProvider(app)
```

Note many other frameworks change their default JSON serailiser to
improve the micro-benchmark performance and hence the comparison
becomes between serialisers rather than the frameworks - be aware that
micro-benchmarks are highly misleading.

## 9. Customising url_for, abort, and redirect

The Flask helper functions `url_for`, `abort`, and `redirect` are now
customisable allowing you to define what they do. This follows the
Flask pattern of allowing customisation via app methods, specifically
`app.url_for`, `app.aborter`, and `app.redirect`.

## 10. Using `flask run`

Flask apps have a `run` method allowing the app to be run in
development, However, the better modern way is to call `flask run` on
the command line. This is best used with the `--app` option to specify
the app to run e.g. if the app is called `app` in the module `main.py`
the explicit command is:

```shell
flask --app main:app run
```

I'd recommend adding the `--debug` flag to trigger the reloader (so
that the app reloads on code changes):

```shell
flask --app main:app --debug run
```

See also the `flask routes` command, which outputs the routes defined
in the app.

## 11. Custom command line interface

It is possible to extend the `flask` CLI with your own custom
commands, for example to create a user called `bob` via `flask
create-user bob` the following can be used:

```python
import click

@app.cli.command("create-user")
@click.argument("name")
def create_user(name):
    ...
```

The full capabilities of [click](https://click.palletsprojects.com)
(another Pallets project) are available.

## 12. Async workers

Whilst technically not a new feature, I find many people to be unaware
that Flask can be deployed with async workers. Specifically I mean
running within an event loop that yields on IO, much like asyncio
provides via the standard library. Using an async worker will almost
certainly improve the performance of your app, as web applications
often do a lot of concurrent IO.

I like to use the [gevent](https://www.gevent.org/) worker with
[Gunicorn](https://gunicorn.org) for this, firstly by installing `pip
install gunicorn[gevent]` and then running my app via:

```shell
gunicorn -k gevent main:app
```

## 13. Using Quart

Quart is a reimplementation of Flask using async/await thereby being
an [ASGI](https://asgi.readthedocs.io/en/latest/) rather than
[WSGI](https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface)
framework (as Flask is). This allows async/await based libraries and
extensions to be used throughout - whereas async/await is
[limited](https://flask.palletsprojects.com/en/2.1.x/async-await/) to
certain functions in Flask.

Our aim is to merge Flask and Quart once we overcome some large
technical hurdles. For now we maintain both as part of the
[Pallets](https://palletsprojects.com) group.

This example usage of [Quart](https://quart.palletsprojects.com/) is
with [QuartSchema](https://quart-schema.readthedocs.io/) to provide
pydantic based validation and autogeneration of OpenAPI documentation:

```python
from dataclasses import dataclass

from quart_schema import QuartSchema, validate_response

@dataclass
class PetOut:
    id: int
    name: str
    category: str

@app.get("/pets/<int:pet_id>")
@validate_response(PetOut)
async def get_pet(pet_id):
    ...
```

The autogenerated docs are at `/docs` by default. In addition running
the `quart schema` command will output the OpenAPI schema to the
terminal.

# Conclusion

Thirteen years on Flask is still under active development and still
improving. I look forward to what the next decade brings.
"""
