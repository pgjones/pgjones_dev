date = "2023-01-30"
id = "modern-flask-2023"
preview = true
summary = """
10 tips and techniques for writing modern Flask apps.
"""
title = "Modern Flask - 10 tips and techniques"

body = """

Flask is approaching its 13th birthday, still in active development,
and still adding features that make it easier for you to build your
web application. On release the industry and Flask focused on server
rendered pages, now there is a as strong a focus on APIs both for
client rendered pages and services. In Flask has modernised by adding
features that make API development easier, as shown in this simple
example:

```python
from flask import Flask, ResponseReturnValue

app = Flask(__name__)

@app.get("/")
def index() -> ResponseReturnValue:
    return {"hello": "world"}
```

## 1. Shorthand method decorators

Flask pioneered the concise decorator approach for defining the
path-handler relationship in a form that allows for multiple
HTTP-methods. This is particularly useful for server rendered forms,
as shown:

```python
from flask import redirect, render_template, request, url_for

@app.route("/page", methods={"GET", "POST"})
def page():
    if request.method:
        ...  # Handle form post
        return redirect(url_form("home"))
    return render_template("form.html")
```

When writing APIs this syntax can get cumbersome and so the modern
approach in Flask is to use a shorthand when only one HTTP-method is
needed, as shown:

```python
@app.post("/resource")
def create_resource():
    data = request.get_json()
    ...
```

With this shorthand the common HTTP-methods {GET, POST, PUT, DELETE,
PATCH} are all available in shorthand. The other methods {HEAD,
CONNECT, OPTIONS, TRACE} are mostly automatically handled by Flask.

## 2. JSON return values

Flask provides the `jsonify` function to create a JSON response,
rather than a HTML response:

```python
from flask import jsonify

@app.get("/")
def resource():
    return jsonify({"attribute": "data"})
```

As with the `route` decorator, this syntax can also be cumbersome and
so the modern approach is to return the dictionary directly:

```python
@app.get("/")
def resource():
    return {"attribute": "data"}
```

I find in practice it is preferable to always return an envelope,
however list responses are also understood as JSON:

```python
@app.get("/")
def resource():
    return [1, 2, 3]
```

## 3. Configuration via the environment

A Twelve-Factor app will store its config in the environment, rather
than in a file (or elsewhere). This is now supported in Flask via the
config `from_prefixed_env` method:

```python
app.config.from_prefixed_env()
```

Which loads all the environment variables starting with `FLASK_` into
the config so that `FLASK_KEY=1` means `app.config["KEY"] == 1`.

As environment variables are not universally liked, Flask still allows
for loading for a file - in any format you like:

```python
import json
import tomllib

app.config.from_file("config.toml", tomllib.loads)
app.config.from_file("config.json", json.loads)
```

## 4. Autogenerated OpenAPI documentation

When writing RESTful APIs OpenAPI has become the go to standard for
documenting the API for both human and computer usage. On this basis
many libraries that offer serialisation and validation have added
OpenAPI autogeneration giving a wide choice. As always Flask takes a
agnostic stance with the Flaskeco system suppling many great
options. For example with Marshmallow, consider
[APIFlask](https://apiflask.com/):

```python
from apiflask import APIFlask, Schema
from apiflask.fields import Integer, String

app = APIFlask(__name__)

class PetOut(Schema):
    id = Integer()
    name = String()
    category = String()

@app.get("/pets/<int:pet_id>")
@app.output(PetOut)
def get_pet(pet_id):
    ...
```

Which has autogenerated docs at `/docs` by default.

Alternatively if you prefer [Pydantic's](https://docs.pydantic.dev)
syntax, consider
[Flask-Pydantic-Spec](https://github.com/turner-townsend/flask-pydantic-spec):

```python
from pydantic import BaseModel
from flask_pydantic_spec import FlaskPydanticSpec, Response

api = FlaskPydanticSpec("flask")

class PetOut(BaseModel):
    id: int
    name: str
    category: str

@app.get("/pets/<int:pet_id>")
@api.validate(resp=Response(HTTP_200=PetOut))
def get_pet(pet_id):
    ...
```

(There are many more libraries in the ecosystem if you prefer a
different syntax).

## 5. Type hinting

Using type hints and type checkers have really improved the quality of
my code. Fortunately, Flask is fully type hinted which helps ensure
any code I write using Flask is also checked. For example the
`ResponseReturnValue` type can be used to check that you return a
valid value:

```python
from flask import ResponseReturnValue

@app.get("/")
def index() -> ResponseReturnValue:
    headers = {}
    status = 200
    return "Hello", headers, status  # Type checkers will error here
```

As the correct return value should be `return "Hello", status,
headers` type checkers will error saving an annoying error.

## 6. Using async libraries

With the introduction of async/await in Python 3.5 many new libraries
have been written utilising the syntax. To use these libraries the
calling code must be a async function. This is now possible in flask:

```python
import httpx

@app.get("/")
async def index():
    async with httpx.AsyncClient() as client:
        result = await client.get("https://www.example.com")
```

(See also #10 Using Quart, for more on async).

## 7. Nested blueprints

Flask allows apps to be split into blueprints, thereby allowing
related routes to be grouped together. Modern Flask allows nested
blueprints, thereby allowing related routes to be grouped to be
grouped together across multiple blueprints.

As an example consider if you have an monitor blueprint that you wish
to use on both the shop and admin parts of your app:

```python
shop = Blueprint("shop", __name__)
admin = Blueprint("admin", __name__)

monitor = Blueprint("monitor", __name__)

@monitor.get("/")
def status():
    retrun {"running": True}

admin.register_blueprint(monitor, url_prefix="/monitor")
shop.register_blueprint(monitor, url_prefix="/monitor")

app.register_blueprint(admin, url_prefix="/admin")
app.register_blueprint(shop, url_prefix="/shop")
```

The paths `/admin/monitor` and `/shop/monitor` now both call the
`status` route-handler. Blueprints can also be given subdomains, which
also nest.

## 8. Customising JSON serialisation

By default Flask serialises JSON using the standard library `json`
module. This can be customised, as may be desired to support
additional features, or to utilise a more performant serialiser.

Customisation is achieved by implementing a JSONProvider, for example
using [orjson](https://pypi.org/project/orjson) (a faster serialiser)
can be achieved via:

```python
from flask.json.provider import JSONProvider
import orjson

class OrJSONProvider(JSONProvider):
    def dumps(self, obj, *, option=None, **kwargs):
        if option is None:
            option = orjson.OPT_APPEND_NEWLINE | orjson.OPT_NAIVE_UTC

        return orjson.dumps(obj, option=option).decode()

    def loads(self, s, **kwargs):
        return orjson.loads(s)

app.json = OrJSONProvider(app)
```

Note many other frameworks change their default JSON serailiser to
improve the micro-benchmark performance and hence the comparison
becomes between serialisers rather than the framework - be aware that
micro-benchmarks are highly misleading.

## 9. Customising url_for, abort, and redirect

The Flask helper functions `url_for`, `abort`, and `redirect` are now
customisable allowing you to define what they do. This follows the
Flask pattern of allowing customisation via app methods, specifically
`app.url_for`, `app.aborter`, and `app.redirect`.

## 10. Using Quart

Quart is a reimplementation of Flask using async/await thereby being
an ASGI rather than WSGI framework (as Flask is). This allows
async/await based libraries and extensions to be used throughout -
whereas async/await is limited to certain functions in Flask.

Our aim is to merge Flask and Quart, once we overcome some large
technical hurdles. For now though we maintain both as part of the
[Pallets](https://palletsprojects.com) group.

This example usage of [Quart](https://quart.palletsprojects.com/) and
[QuartSchema](https://quart-schema.readthedocs.io/), to utilise
pydantic based validation and autogeneration of OpenAPI documentation:

```python
from dataclasses import dataclass

from quart_schema import QuartSchema, validate_response

@dataclass
class PetOut:
    id: int
    name: str
    category: str

@app.get("/pets/<int:pet_id>")
@validate_response(PetOut)
async def get_pet(pet_id):
    ...
```

The autogenerated docs are at `/docs` by default.

# Conclusion

Thirteen years on Flask is still under active development and still
improving. I look forward to what the next decade brings.

"""
